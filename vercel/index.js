// COMMENT GENERATION

// generates comments related to the user input when the 'generate' button is pressed
async function generate() {
    const input = document.getElementById("userThemeInput");
    var theme;
    var comments;

    disableButton(this);
    input.disabled = true;

    // if 
    if (this.id === "generateCustomButton") {
        theme = capitalise(input.value);
        updateSpan("generatedTheme", theme);

        // the comments returned from the database are 
        comments = await getCommentsFromDatabase(theme);
        if (comments != undefined) {
            comments = formatJSON(comments);
            console.log("Theme and comments retrieved from database!");
        }
    }
    // if 
    else if (this.id === "generateRandomButton") {
        updateSpan("generatedTheme", "?");

        // theme and comments are included in the 'comments' returned from the database
        comments = await getCommentsFromDatabase("random");
        theme = comments.theme;
        comments = comments.comments;
        comments = formatJSON(comments);
        console.log("Theme and comments retrieved from database!");
    }
    // reroll button?
    // else if (this.id === "rerollButton") {
        // const minGroupNum = comments.comments[0].group;
        // const maxGroupNum = comments.comments[comments.comments.length - 1].group;
    // }

    // if the custom theme does not exist OR the generation is a reroll, call gemini to generate and store in database
    if (comments === undefined) {
        comments = await callGemini(theme, type);
        storeCommentsInDatabase(theme, comments);
        console.log("Theme and comments generated by Gemini!");
    }

    // if theme was randomly generated, maybe hide the true theme behind display toggle button?
    
    displayGeneration(comments);
    enableButton(this);
    input.disabled = false;
    input.value = "";
}
document.getElementById("generateCustomButton").addEventListener("click", generate);
document.getElementById("generateRandomButton").addEventListener("click", generate);

// reroll function
function reroll() {
    // check database for another group of comments
    // if no have, ask gemini to generate more and store accordingly
}

// re-styles the button and prevents it from being clicked
function disableButton(button) {
    button.disabled = true;
    button.classList.add("active");
    
    resizeButton(button, "Generating");
    
    const loaderSpan = button.children[1];
    loaderSpan.classList.add("active");
}

// re-styles the button and allows it to be clicked again
function enableButton(button) {
    const loaderSpan = button.children[1];
    loaderSpan.classList.remove("active");

    resizeButton(button, "Generate");

    button.classList.remove("active");
    button.disabled = false;
}

// re-styles the button and changes the text
function resizeButton(button, textChange) {
    const startWidth = button.offsetWidth;

    // changes the text of the button
    const generateSpan = button.children[0];
    generateSpan.innerHTML = textChange;

    const endWidth = button.offsetWidth;

    // changes the width of the button
    button.style.width = startWidth + "px";
    button.classList.add("resize");

    void button.offsetWidth;

    button.style.width = endWidth + "px";

    // sets a smooth transition for the button to resize
    const onTransitionEnd = (e) => {
        if (e.propertyName === "width") {
            button.classList.remove("resize");
            button.style.width = "auto";
            button.removeEventListener("transitionend", onTransitionEnd);
        }
    };
    button.addEventListener("transitionend", onTransitionEnd);
}

var excludedIds = [4];
var groupNum = 1;

// finds the theme and returns related comments (if any) from the database
async function getCommentsFromDatabase(theme) {
    let body = {
        type: "database",
        action: "getComments",
        theme: theme
    };

    // random generation passes in the list of excluded themes into the request
    if (theme === "random") {
        body.excludedIds = excludedIds;
    }

    try {
        const response = await fetch("/api/server", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const comments = await response.json();

        // if all themes have been retrieved in random generation, reset the list of excluded themes
        if (comments.reset) {
            excludedIds = [4];
            return getCommentsFromDatabase("random");
        }

        // add the retrieved theme's id to the list to exclude it from the next random generation call
        if (theme === "random") {
            excludedIds.push(comments.id);
        }

        return comments;
    }
    // handling errors (i.e. a theme does not exist in the database)
    catch (error) {
        console.error("Error fetching data from Prisma Database: ", error);
        return null;
    }
}

// formatting retrieved comments from the database into a JSON object
function formatJSON(comments) {
    // implicitly takes the first group of comments from the retrieved comments
    const commentsJSON = {
        "comment1": comments[0].comment,
        "comment2": comments[1].comment,
        "comment3": comments[2].comment,
        "comment4": comments[3].comment,
        "author1": comments[0].author,
        "author2": comments[1].author,
        "author3": comments[2].author,
        "author4": comments[3].author
    };
    return commentsJSON;
}

// storing a new theme and its related comments in the database
async function storeCommentsInDatabase(theme, comments) {
    try {
        const response = await fetch("/api/server", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                type: "database",
                action: "storeComments",
                theme: theme,
                comments: comments
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        return null;
    }
    catch (error) {
        console.error("Error storing theme/ comments in Prisma Database: ", error);
        return null;
    }
}

// sends a request to the backend to call the gemini api to generate comments
async function callGemini(theme, type) {
    var text;
    switch (type) {
        case 'custom':
            text = `You are a setter for section II of the GAMSAT exam. \
                    Find or generate 4 short, simple, and succinct comments in the style of the exam on the theme of ${theme}. \
                    If possible, comments should come from notable authors. If not, do not include any author for the specific comment. \
                    Only include the full names of the authors, and not their professions or positions.`;
            break;
        // case 'reroll':
        //     text = `You are a setter for section II of the GAMSAT exam. \
        //             Find or generate 4 short, simple, and succinct comments in the style of the exam on any one-word theme. \
        //             If possible, comments should come from notable authors. If not, do not include any author for the specific comment. \
        //             Only include the full names of the authors, and not their professions or positions.`;
        //     break;
    }

    // specifying the type of response to be received from gemini
    const requestBody = {
        // initialising the request for the api (i.e. generating comments based on theme)
        contents: [{
            parts: [{
                text: text
            }]
        }],
        // configuring the number of comments required in the response (i.e. 4)
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "object",
                properties: {
                    comment1: {
                        type: "string",
                        description: "The first comment"
                    },
                    author1: {
                        type: "string",
                        description: "The author of the first comment"
                    },
                    comment2: {
                        type: "string",
                        description: "The second comment"
                    },
                    author2: {
                        type: "string",
                        description: "The author of the second comment"
                    },
                    comment3: {
                        type: "string",
                        description: "The second comment"
                    },
                    author3: {
                        type: "string",
                        description: "The author of the second comment"
                    },
                    comment4: {
                        type: "string",
                        description: "The second comment"
                    },
                    author4: {
                        type: "string",
                        description: "The author of the second comment"
                    }
                },
                required: ["comment1", "author1", "comment2", "author2", "comment3", "author3", "comment4", "author4"]
            }
        }
    };

    // the response is received from the backend in the form of 4 comments
    try {
        const response = await fetch("/api/server", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody),
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        const comments = JSON.parse(data.candidates[0].content.parts[0].text);
        return comments;
    }

    // handling errors with the gemini api
    catch (error) {
        console.error("Error fetching structured output from Gemini API: ", error);
        return null;
    }
}

// displays the generated comments on the screen
function displayGeneration(comments) {
    const displayBox = document.getElementById("userDisplayBox");
    const startHeight = displayBox.offsetHeight;

    // get the initial positions of the comment numbers before the comments are updated/ box is resized 
    const commentNumbers = document.querySelectorAll(".commentNumber");
    const initialPositions = Array.from(commentNumbers).map(num => {
        num.style.transition = "none";
        num.style.transform = "translateY(0)";
        return num.getBoundingClientRect().top;
    });

    updateSpan("comment1", comments.comment1);
    updateSpan("comment2", comments.comment2);
    updateSpan("comment3", comments.comment3);
    updateSpan("comment4", comments.comment4);

    updateSpan("author1", comments.author1);
    updateSpan("author2", comments.author2);
    updateSpan("author3", comments.author3);
    updateSpan("author4", comments.author4);

    // setting the new positions for the comment numbers to slowly move to
    commentNumbers.forEach((num, index) => {
        const newPosition = num.getBoundingClientRect().top;
        const diff = initialPositions[index] - newPosition;
        num.style.transform = `translateY(${diff}px)`;
    })

    // updating the box for the comment numbers to change positions
    void displayBox.offsetHeight;
    commentNumbers.forEach((num) => {
        num.style.transition = "transform 1s ease-in-out";
    })

    // animation
    requestAnimationFrame(() => {
        commentNumbers.forEach(num => {
            num.style.transform = "translateY(0)";
        })
    })

    // resizing the displayBox based on calculations
    const endHeight = displayBox.offsetHeight;

    if (endHeight !== startHeight) {
        displayBox.style.height = startHeight + "px";
        displayBox.classList.add("resize");
    
        void displayBox.offsetHeight;
        displayBox.style.height = endHeight + "px";
    
        const onTransitionEnd = (e) => {
            if (e.propertyName === "height") {
                displayBox.classList.remove("resize");
                displayBox.style.height = "auto";
                displayBox.removeEventListener("transitionend", onTransitionEnd);
            }
        };
        displayBox.addEventListener("transitionend", onTransitionEnd);
    }
}

// updates the text of a span and fades it in smoothly
function updateSpan(spanIdentifier, spanText) {
    const span = document.getElementById(spanIdentifier);
    span.style.opacity = 0;
    span.style.transition = "none";
    
    span.textContent = spanText;

    void span.offsetWidth;

    span.style.transition = "opacity 1s ease-in-out";
    span.style.opacity = 1;
}

// capitalises the first letter of each word in the theme for aesthetics
function capitalise(string) {
    const words = string.split(" ");

    // iterates through the 'words' array and capitalises the first letter of each word
    const capitalisedString = words.map(word => {
        if (word.length === 0) {
            return "";
        }
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    });

    // joins the map of capitalised words together to form a single string
    return capitalisedString.join(" ");
}

// TIMER

var interval;
var time = 0;

// gets the user inputted time and starts the timer
function toggleTimer() {
    const userTime = document.getElementById("userTimeInput").value;
    const buttonValue = document.getElementById("startButton").innerHTML;

    if (buttonValue === "Start") {
        // if the user has inputted a time and if no previous timer has been inputted, process the new time
        if (userTime != "") {
            time = userTime * 60;
        }
        // if time is not 0 (i.e. invalid), start the timer and toggle the button to stop the timer
        if (time != 0) {
            interval = setInterval(timerInterval, 1000); // makes the timer run every second
            document.getElementById("userTimeInput").value = "";
            document.getElementById("startButton").innerHTML = "Stop";
        }
        displayTime();
    }

    else if (buttonValue === "Stop") {
        clearInterval(interval);
        document.getElementById("startButton").innerHTML = "Start";
    }
}
document.getElementById("startButton").addEventListener("click", toggleTimer);

// resets the timer once the countdown is complete
function resetTimer() {
    if (time != 0) {
        time = 0;
        clearInterval(interval);
        document.getElementById("countdown").innerHTML = "00:00";
        document.getElementById("startButton").innerHTML = "Start";
    }
}
document.getElementById("resetButton").addEventListener("click", resetTimer);

// runs every second and ticks down the timer
function timerInterval() {
    time -= 1;
    displayTime();
    if (time <= 0) {
        clearInterval(interval);
        time = 0;
        document.getElementById("countdown").innerHTML = "00:00";
        document.getElementById("startButton").innerHTML = "Start";
        document.getElementById("editor").disabled = true;
        document.getElementById("unlockButton").classList.add("show");
    }
}

// displays the timer on screen
function displayTime() {
    const minutes = Math.floor(time / 60);
    const seconds = time % 60;
    const paddedMins = minutes.toString().padStart(2, "0");
    const paddedSecs = seconds.toString().padStart(2, "0");
    document.getElementById("countdown").innerHTML = paddedMins + ":" + paddedSecs;
}

// TEXT EDITOR

// connecting the undo and redo keyboard shortcuts to the undo and redo buttons
const editor = document.getElementById("editor");

function undo() {
    editor.focus();
    document.execCommand("undo", false, null);
}
document.getElementById("undoButton").addEventListener("click", undo);

function redo() {
    editor.focus();
    document.execCommand("redo", false, null);
}
document.getElementById("redoButton").addEventListener("click", redo);

// unlocks the editor and hides the 'unlock' button
function unlock() {
    document.getElementById("editor").disabled = false;
    document.getElementById("unlockButton").classList.remove("show");
}
document.getElementById("unlockButton").addEventListener("click", unlock);

// disabling the cut and paste functions
function disableFunctions() {
    const textarea = document.getElementById("editor");
    if (textarea) {
        textarea.addEventListener('paste', function(event) {
            event.preventDefault();
        });

        textarea.addEventListener('cut', function(event) {
            event.preventDefault();
        });
    }
}
document.addEventListener('DOMContentLoaded', disableFunctions);
